// Copyright 2015 clair authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pgsql

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"reflect"
	"time"

	"github.com/coreos/clair/database"
	"github.com/coreos/clair/utils"
	cerrors "github.com/coreos/clair/utils/errors"
	"github.com/coreos/clair/utils/types"
	"github.com/guregu/null/zero"
)

func (pgSQL *pgSQL) FindVulnerability(namespaceName, name string) (database.Vulnerability, error) {
	return findVulnerability(pgSQL, namespaceName, name, false)
}

func findVulnerability(queryer Queryer, namespaceName, name string, forUpdate bool) (database.Vulnerability, error) {
	defer observeQueryTime("findVulnerability", "all", time.Now())

	vulnerability := database.Vulnerability{
		Name: name,
		Namespace: database.Namespace{
			Name: namespaceName,
		},
	}

	// Find Vulnerability.
	queryName := "f_vulnerability"
	if forUpdate {
		queryName = "f_vulnerability_for_update"
	}

	rows, err := queryer.Query(getQuery(queryName), namespaceName, name)
	if err != nil {
		return vulnerability, handleError(queryName, err)
	}
	defer rows.Close()

	// Iterate to scan the Vulnerability and its FixedIn FeatureVersions.
	for rows.Next() {
		var featureVersionID zero.Int
		var featureVersionVersion zero.String
		var featureVersionFeatureName zero.String

		err := rows.Scan(&vulnerability.ID, &vulnerability.Namespace.ID, &vulnerability.Description,
			&vulnerability.Link, &vulnerability.Severity, &vulnerability.Metadata,
			&featureVersionVersion, &featureVersionID, &featureVersionFeatureName)
		if err != nil {
			return vulnerability, handleError(queryName+".Scan()", err)
		}

		if !featureVersionID.IsZero() {
			// Note that the ID we fill in featureVersion is actually a Feature ID, and not
			// a FeatureVersion ID.
			featureVersion := database.FeatureVersion{
				Model: database.Model{ID: int(featureVersionID.Int64)},
				Feature: database.Feature{
					Model:     database.Model{ID: int(featureVersionID.Int64)},
					Namespace: vulnerability.Namespace,
					Name:      featureVersionFeatureName.String,
				},
				Version: types.NewVersionUnsafe(featureVersionVersion.String),
			}
			vulnerability.FixedIn = append(vulnerability.FixedIn, featureVersion)
		}
	}
	if err = rows.Err(); err != nil {
		return vulnerability, handleError("s_featureversions_vulnerabilities.Rows()", err)
	}
	if vulnerability.ID == 0 {
		return vulnerability, cerrors.ErrNotFound
	}

	return vulnerability, nil
}

// FixedIn.Namespace are not necessary, they are overwritten by the vuln.
// By setting the fixed version to minVersion, we can say that the vuln does'nt affect anymore.
func (pgSQL *pgSQL) InsertVulnerabilities(vulnerabilities []database.Vulnerability) error {
	for _, vulnerability := range vulnerabilities {
		err := pgSQL.insertVulnerability(vulnerability)
		if err != nil {
			fmt.Printf("%#v\n", vulnerability)
			return err
		}
	}
	return nil
}

func (pgSQL *pgSQL) insertVulnerability(vulnerability database.Vulnerability) error {
	tf := time.Now()

	// Verify parameters
	if vulnerability.Name == "" || len(vulnerability.FixedIn) == 0 ||
		vulnerability.Namespace.Name == "" || !vulnerability.Severity.IsValid() {
		log.Warning("could not insert an invalid vulnerability")
		return cerrors.NewBadRequestError("could not insert an invalid vulnerability")
	}

	for _, fixedInFeatureVersion := range vulnerability.FixedIn {
		if fixedInFeatureVersion.Feature.Namespace.Name == "" {
			fixedInFeatureVersion.Feature.Namespace.Name = vulnerability.Namespace.Name
		} else if fixedInFeatureVersion.Feature.Namespace.Name != vulnerability.Namespace.Name {
			msg := "could not insert an invalid vulnerability: FixedIn FeatureVersion must be in the " +
				"same namespace as the Vulnerability"
			log.Warning(msg)
			return cerrors.NewBadRequestError(msg)
		}
	}

	// We do `defer observeQueryTime` here because we don't want to observe invalid vulnerabilities.
	defer observeQueryTime("insertVulnerability", "all", tf)

	// Find or insert Vulnerability's Namespace.
	namespaceID, err := pgSQL.insertNamespace(vulnerability.Namespace)
	if err != nil {
		return err
	}

	// Begin transaction.
	tx, err := pgSQL.Begin()
	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.Begin()", err)
	}

	// Find vulnerability and its Vulnerability_FixedIn_Features.
	existingVulnerability, err := findVulnerability(tx, vulnerability.Namespace.Name,
		vulnerability.Name, true)
	if err != nil && err != cerrors.ErrNotFound {
		tx.Rollback()
		return err
	}

	// Insert or update vulnerability.
	if existingVulnerability.ID == 0 {
		// The vulnerability is a new one, insert it.
		err = tx.QueryRow(getQuery("i_vulnerability"), namespaceID, vulnerability.Name,
			vulnerability.Description, vulnerability.Link, &vulnerability.Severity,
			&vulnerability.Metadata).Scan(&vulnerability.ID)
		if err != nil {
			tx.Rollback()
			return handleError("i_vulnerability", err)
		}
	} else {
		// The vulnerability exists, update it.
		if vulnerability.Description != existingVulnerability.Description ||
			vulnerability.Link != existingVulnerability.Link ||
			vulnerability.Severity != existingVulnerability.Severity ||
			!reflect.DeepEqual(castMetadata(vulnerability.Metadata), existingVulnerability.Metadata) {
			_, err = tx.Exec(getQuery("u_vulnerability"), existingVulnerability.ID,
				vulnerability.Description, vulnerability.Link, &vulnerability.Severity,
				&vulnerability.Metadata)
			if err != nil {
				tx.Rollback()
				return handleError("u_vulnerability", err)
			}
		}

		vulnerability.ID = existingVulnerability.ID
	}

	// Get the new/updated/removed FeatureVersions and the resulting full list.
	var newFIFV, updatedFIFV, removedFIFV []database.FeatureVersion
	if existingVulnerability.ID == 0 {
		// The vulnerability is a new new, the new FeatureVersions are the entire list of FixedIn.
		newFIFV = vulnerability.FixedIn
	} else {
		// The vulnerability exists, compute the lists using diffFixedIn.
		// We overwrite vulnerability.FixedIn with the entire list of FixedIn FeatureVersions, we'll
		// then use the vulnerability in the notification, with that list instead of a potential diff.
		newFIFV, updatedFIFV, removedFIFV, vulnerability.FixedIn =
			diffFixedIn(existingVulnerability.FixedIn, vulnerability.FixedIn)
	}

	// Update Vulnerability_FixedIn_Feature and Vulnerability_Affects_FeatureVersion now.
	if err = pgSQL.updateVulnerabilityFeatureVersions(tx, vulnerability.ID, newFIFV, updatedFIFV,
		removedFIFV); err != nil {
		tx.Rollback()
		return err
	}

	// Create notification.
	notification := database.VulnerabilityNotification{
		NewVulnerability: vulnerability,
	}
	if existingVulnerability.ID != 0 {
		notification.OldVulnerability = &existingVulnerability
	}

	if err := pgSQL.insertNotification(tx, notification); err != nil {
		return err
	}

	// Commit transaction.
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.Commit()", err)
	}

	return nil
}

// castMetadata marshals the given database.MetadataMap and unmarshals it again to make sure that
// everything has the interface{} type.
// It is required when comparing crafted MetadataMap against MetadataMap that we get from the
// database.
func castMetadata(m database.MetadataMap) database.MetadataMap {
	c := make(database.MetadataMap)
	j, _ := json.Marshal(m)
	json.Unmarshal(j, &c)
	return c
}

func diffFixedIn(existingFIFVList, newFIFVList []database.FeatureVersion) (newFIFV, updatedFIFV, removedFIFV, allFIFV []database.FeatureVersion) {
	// Build FeatureVersion.Feature.Namespace.Name:FeatureVersion.Feature.Name (NaN) structures.
	allFIFVMap, _ := createFeatureVersionNameMap(existingFIFVList)
	vulnerabilityFixedInNameMap, vulnerabilityFixedInNameSlice := createFeatureVersionNameMap(newFIFVList)
	existingFixedInMapNameMap, existingFixedInNameSlice := createFeatureVersionNameMap(existingFIFVList)

	// Calculate the new FixedIn FeatureVersion NaN and updated ones.
	newFixedInName := utils.CompareStringLists(vulnerabilityFixedInNameSlice,
		existingFixedInNameSlice)
	updatedFixedInName := utils.CompareStringListsInBoth(vulnerabilityFixedInNameSlice,
		existingFixedInNameSlice)

	for _, nan := range newFixedInName {
		fv := vulnerabilityFixedInNameMap[nan]
		if fv.Version == types.MinVersion {
			// We don't want to mark a Feature as fixed in MinVersion. MinVersion only makes sense when a
			// Feature is already marked as fixed in some version, in which case we would be in the
			// "updatedFixedInFeatureVersions" loop and removes the fixed in mark.
			continue
		}

		newFIFV = append(newFIFV, fv)
		allFIFVMap[fv.Feature.Namespace.Name+":"+fv.Feature.Name] = fv
	}

	for _, nan := range updatedFixedInName {
		fv := existingFixedInMapNameMap[nan]
		fv.Version = vulnerabilityFixedInNameMap[nan].Version

		if existingFixedInMapNameMap[nan].Version == fv.Version {
			// Versions are actually the same!
			// Even though they appear in both lists, it's not an update.
			continue
		}

		if fv.Version != types.MinVersion {
			updatedFIFV = append(updatedFIFV, fv)
			allFIFVMap[fv.Feature.Namespace.Name+":"+fv.Feature.Name] = fv
		} else {
			removedFIFV = append(removedFIFV, fv)
			delete(allFIFVMap, fv.Feature.Namespace.Name+":"+fv.Feature.Name)
		}
	}

	for _, fv := range allFIFVMap {
		allFIFV = append(allFIFV, fv)
	}

	return
}

func createFeatureVersionNameMap(features []database.FeatureVersion) (map[string]database.FeatureVersion, []string) {
	m := make(map[string]database.FeatureVersion, 0)
	s := make([]string, 0, len(features))

	for i := 0; i < len(features); i++ {
		featureVersion := features[i]
		m[featureVersion.Feature.Name] = featureVersion
		s = append(s, featureVersion.Feature.Name)
	}

	return m, s
}

func (pgSQL *pgSQL) InsertVulnerabilityFixes(vulnerabilityNamespace, vulnerabilityName string, fixes []database.FeatureVersion) error {
	// Verify parameters
	for _, fifv := range fixes {
		if fifv.Feature.Namespace.Name == "" {
			fifv.Feature.Namespace.Name = vulnerabilityNamespace
		} else if fifv.Feature.Namespace.Name != vulnerabilityNamespace {
			msg := "could not add/update a FixedIn FeatureVersion: FixedIn FeatureVersion must be in the " +
				"same namespace as the Vulnerability"
			log.Warning(msg)
			return cerrors.NewBadRequestError(msg)
		}
	}

	f := func(vulnerability database.Vulnerability) (newFIFV, updatedFIFV, removedFIFV, allFIFV []database.FeatureVersion, err error) {
		newFIFV, updatedFIFV, _, allFIFV = diffFixedIn(vulnerability.FixedIn, fixes)
		return
	}

	return pgSQL.doVulnerabilityFixes(vulnerabilityNamespace, vulnerabilityName, f)
}

func (pgSQL *pgSQL) DeleteVulnerabilityFix(vulnerabilityNamespace, vulnerabilityName, featureName string) error {
	f := func(vulnerability database.Vulnerability) (newFIFV, updatedFIFV, removedFIFV, allFIFV []database.FeatureVersion, err error) {
		// Search the specified featureName.
		for i, vulnerabilityFV := range vulnerability.FixedIn {
			if vulnerabilityFV.Feature.Name == featureName {
				removedFIFV = append(removedFIFV, vulnerabilityFV)
				allFIFV = append(vulnerability.FixedIn[:i], vulnerability.FixedIn[i+1:]...)
				return
			}
		}

		err = cerrors.ErrNotFound
		return
	}

	return pgSQL.doVulnerabilityFixes(vulnerabilityNamespace, vulnerabilityName, f)
}

// doVulnerabilityFixes is used by InsertVulnerabilityFixes and DeleteVulnerabilityFix. It
// adds/updates/removes FeatureVersions on the specified vulnerability using
// updateVulnerabilityFeatureVersions and creates a database.VulnerabilityNotification.
func (pgSQL *pgSQL) doVulnerabilityFixes(vulnerabilityNamespace, vulnerabilityName string, f func(vulnerability database.Vulnerability) (newFIFV, updatedFIFV, removedFIFV, allFIFV []database.FeatureVersion, err error)) error {
	// Begin transaction.
	tx, err := pgSQL.Begin()
	if err != nil {
		tx.Rollback()
		return handleError("doVulnerabilityFixes.Begin()", err)
	}

	// Select for update the vulnerability in order to prevent everyone else from executing updates
	// on the vulnerability (and consequently on Vulnerability_FixedIn_Feature for that particular
	// vulnerability)
	vulnerability, err := findVulnerability(tx, vulnerabilityNamespace, vulnerabilityName, true)
	if err != nil {
		tx.Rollback()
		return err
	}

	// Get the new/updated/removed FeatureVersions and the resulting full list, using the given fct.
	newFIFV, updatedFIFV, removedFIFV, allFIFV, err := f(vulnerability)
	if err != nil {
		tx.Rollback()
		return err
	}
	if len(newFIFV) == 0 && len(updatedFIFV) == 0 && len(removedFIFV) == 0 {
		// Nothing to do.
		tx.Commit()
		return nil
	}

	// Update Vulnerability_FixedIn_Feature and Vulnerability_Affects_FeatureVersion now.
	err = pgSQL.updateVulnerabilityFeatureVersions(tx, vulnerability.ID, newFIFV, updatedFIFV,
		removedFIFV)
	if err != nil {
		tx.Rollback()
		return err
	}

	// Create notification.
	newVulnerability := vulnerability
	newVulnerability.FixedIn = allFIFV

	notification := database.VulnerabilityNotification{
		NewVulnerability: newVulnerability,
		OldVulnerability: &vulnerability,
	}

	if err := pgSQL.insertNotification(tx, notification); err != nil {
		return err
	}

	// Commit transaction.
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.Commit()", err)
	}

	return nil
}

func (pgSQL *pgSQL) updateVulnerabilityFeatureVersions(tx *sql.Tx, vulnerabilityID int, newFIFV, updatedFIFV, removedFIFV []database.FeatureVersion) error {
	defer observeQueryTime("updateVulnerabilityFeatureVersions", "all", time.Now())

	// Insert or find the Features.
	// TODO(Quentin-M): Batch me.
	var err error
	var features []*database.Feature
	for _, fv := range newFIFV {
		features = append(features, &fv.Feature)
	}
	for _, fv := range updatedFIFV {
		features = append(features, &fv.Feature)
	}
	for _, fv := range removedFIFV {
		features = append(features, &fv.Feature)
	}
	for _, feature := range features {
		if feature.ID == 0 {
			if feature.ID, err = pgSQL.insertFeature(*feature); err != nil {
				return err
			}
		}
	}

	// Lock Vulnerability_Affects_FeatureVersion exclusively.
	// We want to prevent InsertFeatureVersion to modify it.
	promConcurrentLockVAFV.Inc()
	defer promConcurrentLockVAFV.Dec()
	t := time.Now()
	_, err = tx.Exec(getQuery("l_vulnerability_affects_featureversion"))
	observeQueryTime("insertVulnerability", "lock", t)

	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.l_vulnerability_affects_featureversion", err)
	}

	var fixedInID int

	for _, fv := range newFIFV {
		// Insert Vulnerability_FixedIn_Feature.
		err = tx.QueryRow(getQuery("i_vulnerability_fixedin_feature"), vulnerabilityID, fv.Feature.ID,
			&fv.Version).Scan(&fixedInID)
		if err != nil {
			return handleError("i_vulnerability_fixedin_feature", err)
		}

		// Insert Vulnerability_Affects_FeatureVersion.
		err = linkVulnerabilityToFeatureVersions(tx, fixedInID, vulnerabilityID, fv.Feature.ID,
			fv.Version)
		if err != nil {
			return err
		}
	}

	for _, fv := range updatedFIFV {
		// Update Vulnerability_FixedIn_Feature.
		err = tx.QueryRow(getQuery("u_vulnerability_fixedin_feature"), vulnerabilityID,
			fv.Feature.ID, &fv.Version).Scan(&fixedInID)
		if err != nil {
			return handleError("u_vulnerability_fixedin_feature", err)
		}

		// Drop all old Vulnerability_Affects_FeatureVersion.
		_, err = tx.Exec(getQuery("r_vulnerability_affects_featureversion"), fixedInID)
		if err != nil {
			return handleError("r_vulnerability_affects_featureversion", err)
		}

		// Insert Vulnerability_Affects_FeatureVersion.
		err = linkVulnerabilityToFeatureVersions(tx, fixedInID, vulnerabilityID, fv.Feature.ID,
			fv.Version)
		if err != nil {
			return err
		}
	}

	for _, fv := range removedFIFV {
		// Drop it from Vulnerability_FixedIn_Feature and let it cascade to
		// Vulnerability_Affects_FeatureVersion.
		err = tx.QueryRow(getQuery("r_vulnerability_fixedin_feature"), vulnerabilityID,
			fv.Feature.ID).Scan(&fixedInID)
		if err != nil && err != sql.ErrNoRows {
			return handleError("r_vulnerability_fixedin_feature", err)
		}
	}

	return nil
}

func linkVulnerabilityToFeatureVersions(tx *sql.Tx, fixedInID, vulnerabilityID, featureID int, fixedInVersion types.Version) error {
	// Find every FeatureVersions of the Feature that the vulnerability affects.
	// TODO(Quentin-M): LIMIT
	rows, err := tx.Query(getQuery("f_featureversion_by_feature"), featureID)
	if err != nil {
		return handleError("f_featureversion_by_feature", err)
	}
	defer rows.Close()

	var affecteds []database.FeatureVersion
	for rows.Next() {
		var affected database.FeatureVersion

		err := rows.Scan(&affected.ID, &affected.Version)
		if err != nil {
			return handleError("f_featureversion_by_feature.Scan()", err)
		}

		if affected.Version.Compare(fixedInVersion) < 0 {
			// The version of the FeatureVersion is lower than the fixed version of this vulnerability,
			// thus, this FeatureVersion is affected by it.
			affecteds = append(affecteds, affected)
		}
	}
	if err = rows.Err(); err != nil {
		return handleError("f_featureversion_by_feature.Rows()", err)
	}
	rows.Close()

	// Insert into Vulnerability_Affects_FeatureVersion.
	for _, affected := range affecteds {
		// TODO(Quentin-M): Batch me.
		_, err := tx.Exec(getQuery("i_vulnerability_affects_featureversion"), vulnerabilityID,
			affected.ID, fixedInID)
		if err != nil {
			return handleError("i_vulnerability_affects_featureversion", err)
		}
	}

	return nil
}

func (pgSQL *pgSQL) DeleteVulnerability(namespaceName, name string) error {
	defer observeQueryTime("DeleteVulnerability", "all", time.Now())

	result, err := pgSQL.Exec(getQuery("r_vulnerability"), namespaceName, name)
	if err != nil {
		return handleError("r_vulnerability", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return handleError("r_vulnerability.RowsAffected()", err)
	}

	if affected <= 0 {
		return cerrors.ErrNotFound
	}

	return nil
}
